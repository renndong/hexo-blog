---
title: 汇编转移指令
tags: 汇编
categories: 汇编
abbrlink: add0c9cd
date: 2019-02-09 11:46:09
---

在8086CPU中，转移指令可分为如下几类  
* 无条件转移指令，如jmp
* 条件转移指令，如jcxz
* 循环指令，如loop
* 过程
* 中断

在此，只先讨论无条件转移中的jmp，其他东西以后再更

jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP

## 依据位移进行转移的jmp指令
所谓依据位移呢，就是根据转移指令到要转移的目的地址之间相差的字节数来进行转移的，相差的字节数由编译器进行计算给出，在生成的机器指令中只包含相差的字节数，不包含目的地址，这样会是的程序更加的灵活

### jmp short 标号
这种格式的jmp指令实现的是段内短转移，他对IP的修改范围为-128~127，超过这个范围会报错

使用如下面的例子
```asm
codesg segment
    start: mov ax,0
           jmp short s
           add ax,1
        s: inc ax
codesg ends
end start        
```
参照书上的总结就是：jmp short 标号 的功能为：（IP）=(IP)+8位位移

* 8位位移=标号处的地址-jmp指令后的第一个字节的地址（为什么是指令后第一个字节的地址，是因为和cpu执行指令的方式有关）
* short指明此处的位移为8位位移
* 8位位移的范围为-128~127，用补码表示
* 8位位移由编译程序在编译时算出

### jmp near ptr 标号
它和jmp short 标号的功能相似，不过是实现的段内近转移

它实现的功能为：（IP）=（IP）+ 16为位移，类似上面
* 16位位移=标号处的地址-jmp指令后的第一个字节的地址
* near ptr 指明此处的位移为16位位移，进行的是段内近转移
* 16位位移的范围为-32768~32767，用补码表示
* 16为位移由编译程序在编译时给出

## 转移的目的地址在指令中的jmp指令
前面的jmp指令只能进行段间的转移，但是我们有时候需要转移的“更远”，这时候就需要这种类型的指令了
### jmp far ptr 标号
此指令实现的是段间转移，又称为远转移功能如下

* （CS）=标号所在段的段地址，（IP）=标号在段中的偏移地址
* far ptr 指明了用标号的段地址和偏移地址修改CS和IP

例如：
```
codesg segment
 start: mov ax,0
        mov bx,0
        jmp far ptr s
        db 256 dup (0) ;这里用来占空
     s: add ax,1
        inc ax
codesg ends
end start        
```

## 转移地址在寄存器中的jmp指令
### jmp 16位reg
功能：（IP）=（16位reg）

## 转移地址在内存中的jmp指令
转移地址在内存中的jmp指令有两种格式：段内转移和段间转移
### jmp word ptr 内存单元地址（段内转移）
功能：
* 从内存单元地址处开始存放一个字，是转移的目的偏移地址
* 内存单元地址可用寻址方式的任一格式给出

例如：
```
mov ax,0123H
mov ds:[0],ax
jmp word ptr ds:[0]
```

### jmp dword ptr 内存单元地址（段间转移）
功能：
* 从内存单元地址处开始存放者两个字，高地址的字为转移的目的段地址，低地址处为转移的目的偏移地址
* （CS）=（内存单元地址+2），（IP）= （内存单元地址）
* 内存单元地址可以用寻址方式的任何一种格式给出

例如:
```
mov ax,0123H
mov ds:[0],ax
mov word ptr ds:[2],0
jmp dword ptr ds:[0]
```
---
本文总结自王爽的《汇编语言》，如有错误欢迎指正